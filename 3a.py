# -*- coding: utf-8 -*-
"""Project1Exercises3a.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1nXD0pea-grR3Ke4bt2LY_CvfKLn0ErB1
"""

import numpy as np
import tensorflow as tf
import matplotlib.pyplot as plt
import pandas as pd

from sklearn.preprocessing import LabelEncoder
from sklearn.preprocessing import StandardScaler
from sklearn.model_selection import train_test_split

df = pd.read_csv('spaceship-titanic.csv')
df = df[['RoomService', 'FoodCourt', 'Transported']]
label_encoder = LabelEncoder()
df = df.dropna()

x = df[['RoomService', 'FoodCourt']]
y = df['Transported']

scaler = StandardScaler()
x = scaler.fit_transform(x)
y = label_encoder.fit_transform(y)


x_train, x_test, y_train, y_test = train_test_split(x, y, test_size=0.2,  stratify=y)

class KNN:
  
    def __init__(self, nb_classes, x,y, k):
        self.nb_classes = nb_classes
        self.k = k
        self.X = x
        self.Y = y
  
    # Ako imamo odgovore za upit racunamo i accuracy.
    def accuracy(self, query_data):
        matches = 0
        for i in range(len(query_data['x'])):

            # Racunamo kvadriranu euklidsku udaljenost i uzimamo minimalnih k.
            dists = tf.sqrt(tf.reduce_sum(tf.square(tf.subtract(self.X, query_data['x'][i])), axis=1))
            _, idxs = tf.nn.top_k(-dists, self.k)
            classes = tf.gather(self.Y, idxs)
            dists = tf.gather(dists, idxs)
            
            w = tf.fill([self.k], 1/self.k)

            # Svaki red mnozimo svojim glasom i sabiramo glasove po kolonama.
            w_col = tf.reshape(w, (self.k, 1))
            classes_one_hot = tf.one_hot(classes, self.nb_classes)
            scores = tf.reduce_sum(w_col * classes_one_hot, axis=0)
            
            # Klasa sa najvise glasova je hipoteza.
            hyp = tf.argmax(scores)

            
            actual = query_data['y'][i]

            match = (hyp == actual)
            if match:
              matches += 1
                # if i % 100 == 0:
                #     a= len(query_data['y'])
                #     print(f'Test example: {i+1:2}/{a} | Predicted: {hyp} | Actual: {actual} | Match: {match}')
          
        acc = matches / len(query_data['x'])
        return acc


    def predict(self, query_data):
        y_pred = []
        matches = 0
        for i in range(len(query_data['x'])):

            # Racunamo kvadriranu euklidsku udaljenost i uzimamo minimalnih k.
            dists = tf.sqrt(tf.reduce_sum(tf.square(tf.subtract(self.X, query_data['x'][i])), axis=1))
            _, idxs = tf.nn.top_k(-dists, self.k)
            classes = tf.gather(self.Y, idxs)
            dists = tf.gather(dists, idxs)
            
            w = tf.fill([self.k], 1/self.k)

            # Svaki red mnozimo svojim glasom i sabiramo glasove po kolonama.
            w_col = tf.reshape(w, (self.k, 1))
            classes_one_hot = tf.one_hot(classes, self.nb_classes)
            scores = tf.reduce_sum(w_col * classes_one_hot, axis=0)
            
            # Klasa sa najvise glasova je hipoteza.
            hyp = tf.argmax(scores)

            y_pred.append(hyp)
          
        return y_pred

nb_train = len(y_train)
nb_test = len(y_test)

x_train = np.reshape(x_train, [nb_train, -1])
x_test = np.reshape(x_test, [nb_test, -1])

knn = KNN(2,x_train,y_train,15)
y_pred = knn.accuracy({'x': x_test,'y': y_test})
print(y_pred)

from matplotlib.colors import ListedColormap


temp = x_train.transpose()
print(temp.shape)
blue_x = temp[0]
blue_y = temp[1]
blue_x = blue_x[y_train == 1]
blue_y = blue_y[y_train == 1]

red_x = temp[0]
red_y = temp[1]
red_x = red_x[y_train == 0]
red_y = red_y[y_train == 0]

h = .2

cmap_light = ListedColormap(['#FFAAAA', '#AAFFAA', '#AAAAFF'])


  # Plot the decision boundary. For that, we will assign a color to each
  # point in the mesh [x_min, x_max]x[y_min, y_max].
x_min, x_max = temp[0].min() - 1, temp[0].max() + 1
y_min, y_max = temp[1].min() - 1, temp[1].max() + 1
xx, yy = np.meshgrid(np.arange(x_min, x_max, h),
                      np.arange(y_min, y_max, h))
print("Ispis")
print(yy)

Z = knn.predict({'x': np.c_[xx.ravel(), yy.ravel()]})

# Put the result into a color plot
print(np.count_nonzero(Z))
zlist = np.array([])
for tensor in Z:
    zlist=np.append(zlist,tensor.numpy())
zlist = zlist.reshape(xx.shape)
print(type(zlist))
plt.pcolormesh(xx, yy, zlist, cmap=cmap_light)

plt.scatter(blue_x, blue_y, color='blue', alpha=0.5)
plt.scatter(red_x, red_y, color='red', alpha=0.5)
plt.show()